

#include "ns3/antenna-module.h"
#include "ns3/applications-module.h"
#include "ns3/cc-bwp-helper.h"
#include "ns3/config-store-module.h"
#include "ns3/config-store.h"
#include "ns3/core-module.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/ideal-beamforming-algorithm.h"
#include "ns3/internet-apps-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/log.h"
#include "ns3/mobility-module.h"
#include "ns3/network-module.h"
#include "ns3/nr-helper.h"
#include "ns3/nr-mac-scheduler-tdma-rr.h"
#include "ns3/nr-module.h"
#include "ns3/nr-point-to-point-epc-helper.h"
#include "ns3/point-to-point-helper.h"
#include "ns3/point-to-point-module.h"

#include <cmath>
using namespace ns3;

int main(int argc, char *argv[])
{
    uint16_t gNbNum = 1;
    uint16_t ueNumPergNb = 1;

    // ands = 1;
    double centralFrequencyBand = 3.5e9;
    // double bandwidthBand = 3e9;//3기가 헤르즈
    double bandwidthBand = 4e8; // 300 MHz

    uint16_t numerology = 0;
    // SCS설정 0=15kHz 3=120kHz
    //---------------------------------------------------------------------------
    NodeContainer gNbNodes;
    NodeContainer ueNodes;
    MobilityHelper mobility;

    double gNbHeight = 10;
    double ueHeight = 10;

    gNbNodes.Create(gNbNum);
    ueNodes.Create(ueNumPergNb * gNbNum);

    Ptr<ListPositionAllocator> apPositionAlloc =
        CreateObject<ListPositionAllocator>(); // gnb위치 저장
    Ptr<ListPositionAllocator> staPositionAlloc =
        CreateObject<ListPositionAllocator>(); // ue위치 저장
    // 여러 개의 위치를 리스트로 지정하고, 시뮬레이션에서 노드들이 그 위치로 배치되게 해줌

    apPositionAlloc->Add(Vector(0.0, 0.0, gNbHeight));
    staPositionAlloc->Add(Vector(10000, 0.0, ueHeight)); // meter단위

    // 이동성 설정
    mobility.SetMobilityModel("ns3::ConstantPositionMobilityModel");
    // • ConstantPositionMobilityModel : 움직이지 않음
    // • RandomWalk2dMobilityModel : 무작위로 움직임
    // • ConstantVelocityMobilityModel : 정해진 속도로 직선 이동 등등

    // - 무작위
    // mobility.SetMobilityModel(
    //     "ns3::RandomWalk2dMobilityModel",
    //     "Bounds",
    //     RectangleValue(Rectangle(-50, 50, -50, 50)), // 움직일 수 있는 영역
    //     "Distance",
    //     DoubleValue(10.0), // 한 번 움직일 때 거리
    //     "Speed",
    //     StringValue("ns3::ConstantRandomVariable[Constant=2.0]"), // 속도 2m/s 고정
    //     "Direction",
    //     StringValue("ns3::UniformRandomVariable[Min=0.0|Max=6.28318]") // 방향 무작위 (0~2π)
    // );

    // - 움직임 모델 설정
    // // 움직임 모델 설정
    // mobility.SetMobilityModel("ns3::ConstantVelocityMobilityModel");
    // // UE 노드에 먼저 설치
    // mobility.Install(ueNodes);
    // // 속도 설정 (UE들이 x축 방향으로 5m/s로 이동)
    // for (uint32_t i = 0; i < ueNodes.GetN(); ++i)
    // {
    //     Ptr<Node> node = ueNodes.Get(i);
    //     Ptr<ConstantVelocityMobilityModel> mobility =
    //         node->GetObject<ConstantVelocityMobilityModel>();
    //     mobility->SetVelocity(Vector(5.0, 0.0, 0.0)); // x축으로 5m/s
    // }

    mobility.SetPositionAllocator(apPositionAlloc);
    mobility.Install(gNbNodes);

    mobility.SetPositionAllocator(staPositionAlloc);
    mobility.Install(ueNodes);

    // setup the nr simulation
    Ptr<NrPointToPointEpcHelper> nrEpcHelper = CreateObject<NrPointToPointEpcHelper>();
    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();
    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();

    nrHelper->SetBeamformingHelper(idealBeamformingHelper);
    nrHelper->SetEpcHelper(nrEpcHelper);

    // bwp 설정, 부파수 분할, Component Carrier
    /*
     * Setup the configuration of the spectrum. There is a contiguous and a non-contiguous
     * example:
     * 1) One operation band is deployed with 4 contiguous component carriers
     *    (CC)s, which are automatically generated by the ccBwpManager
     * 2) One operation bands non-contiguous case. CCs and BWPs are manually created
     */
    // contiguous는 연속된 주파수 대역으로 자동구성할 때
    // non-contiguous는 수동으로 CC+BWP설정(cttc-nr-cc-bwp-demo.cc 참고)

    BandwidthPartInfoPtrVector allBwps;
    CcBwpCreator ccBwpCreator;

    OperationBandInfo band;

    // For the case of manual configuration of CCs and BWPs
    std::unique_ptr<ComponentCarrierInfo> cc0(new ComponentCarrierInfo());
    std::unique_ptr<BandwidthPartInfo> bwp0(new BandwidthPartInfo());
    std::unique_ptr<BandwidthPartInfo> bwp1(new BandwidthPartInfo());

    std::unique_ptr<ComponentCarrierInfo> cc1(new ComponentCarrierInfo());
    std::unique_ptr<BandwidthPartInfo> bwp2(new BandwidthPartInfo());
    std::unique_ptr<BandwidthPartInfo> bwp3(new BandwidthPartInfo());

    /*
     * CC band configuration n257F (NR Release 15): four contiguous CCs of
     * 400MHz at maximum. In this automated example, each CC contains a single
     * BWP occupying the whole CC bandwidth.
     *
     * The configured spectrum division is:
     * ----------------------------- Band --------------------------------
     * ------CC0------|------CC1-------|-------CC2-------|-------CC3-------
     * ------BWP0-----|------BWP0------|-------BWP0------|-------BWP0------
     *
     * |--------- CC0 --------|--------- CC1 --------|
     * |-- BWP0 --|-- BWP1 -- |-- BWP2 --|-- BWP3 --|
     * 밑에 내가 한거는 두번째 같은 구조
     */

    const uint8_t numContiguousCcs = 2; // 4 CCs per Band

    // Create the configuration for the CcBwpHelper
    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,
                                                   bandwidthBand,
                                                   numContiguousCcs,
                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);

    bandConf.m_numBwp = 2; // 2 BWP per CC

    // By using the configuration created, it is time to make the operation band
    // 위에 설정한대로 자동생성 도우미? 같은 역할
    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);

    // 자동으로 ThreeGppPropagationLossModel 사용
    nrHelper->SetPathlossAttribute("ShadowingEnabled",
                                   BooleanValue(true)); // 신호 감쇠 현상 off
    nrEpcHelper->SetAttribute("S1uLinkDelay", TimeValue(MilliSeconds(0)));
    // gnb<->core network 전송 속도 0ms
    nrHelper->SetSchedulerTypeId(TypeId::LookupByName("ns3::NrMacSchedulerTdmaRR"));
    // 스케줄러 설정(round robin방식임)

    // 빔포밍 설정
    idealBeamformingHelper->SetAttribute("BeamformingMethod",
                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));

    nrHelper->InitializeOperationBand(&band);
    // bnad를 nr시스템에 초기화함 즉 이 밴드 사용한다는 뜻
    allBwps = CcBwpCreator::GetAllBwps({band});
    // band안에 들어있는 모든 bwp출출해서 allbwps에 저장

    double totalTxPower = 9.6;
    double x = pow(10, totalTxPower / 10); // 전송 전력을 watt 단위로 변환
    // totalTxPower = 30 dBm → x = 1 W

    // Antennas for all the UEs
    nrHelper->SetUeAntennaAttribute("NumRows", UintegerValue(2));
    nrHelper->SetUeAntennaAttribute("NumColumns", UintegerValue(4));
    // 2*4 즉 8개 안테나
    nrHelper->SetUeAntennaAttribute("AntennaElement",
                                    PointerValue(CreateObject<IsotropicAntennaModel>()));
    // 등방성 안테나 Isotropical 로 MIMO구현

    // Antennas for all the gNbs
    nrHelper->SetGnbAntennaAttribute("NumRows", UintegerValue(4));
    nrHelper->SetGnbAntennaAttribute("NumColumns", UintegerValue(8));
    nrHelper->SetGnbAntennaAttribute("AntennaElement",
                                     PointerValue(CreateObject<IsotropicAntennaModel>()));

    uint32_t bwpIdForLowLat = 0;
    uint32_t bwpIdForVoice = 1;
    uint32_t bwpIdForVideo = 2;
    uint32_t bwpIdForVideoGaming = 3;

    // 서비스 타입 -> BWP 매핑 (QoS 지정)
    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_LOW_LAT_EMBB",
                                                 UintegerValue(bwpIdForLowLat));
    nrHelper->SetGnbBwpManagerAlgorithmAttribute("GBR_CONV_VOICE", UintegerValue(bwpIdForVoice));
    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_VIDEO_TCP_PREMIUM",
                                                 UintegerValue(bwpIdForVideo));
    nrHelper->SetGnbBwpManagerAlgorithmAttribute("NGBR_VOICE_VIDEO_GAMING",
                                                 UintegerValue(bwpIdForVideoGaming));

    // Install and get the pointers to the NetDevices
    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);
    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);

    int64_t randomStream = 1; // 랜덤 시드 고정 시뮬레이션 돌려도 결과 같게
    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);
    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);

    std::string pattern =
        "F|F|F|F|F|F|F|F|F|F|"; // Pattern can be e.g. "DL|S|UL|UL|DL|DL|S|UL|UL|DL|"
    // F는 flexible
    // D Downlink
    // U Uplink

    // 0번째 gnb의 0,1,2,3번째 bwp에 대한 설정
    // 전체 전력에 대한 부분을 4개로 나누어 0.25를 곱함
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)->SetAttribute("Numerology", UintegerValue(numerology));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)
        ->SetAttribute("TxPower", DoubleValue(10 * log10(0.25 * x)));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)->SetAttribute("Pattern", StringValue(pattern));

    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 1)->SetAttribute("Numerology", UintegerValue(numerology));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 1)
        ->SetAttribute("TxPower", DoubleValue(10 * log10(0.25 * x)));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 1)->SetAttribute("Pattern", StringValue(pattern));

    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 2)->SetAttribute("Numerology", UintegerValue(numerology));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 2)
        ->SetAttribute("TxPower", DoubleValue(10 * log10(0.25 * x)));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 2)->SetAttribute("Pattern", StringValue(pattern));

    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 3)->SetAttribute("Numerology", UintegerValue(numerology));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 3)
        ->SetAttribute("TxPower", DoubleValue(10 * log10(0.25 * x)));
    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 3)->SetAttribute("Pattern", StringValue(pattern));

    // 설정 적용
    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)
    {
        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();
        // gnbNetDev는 gNB디바이스들의 컨테이너(NetDeviceContainer)형식임
        // 각 gNB 디바이스를 NRGnbNetDevice로 타입 캐스팅해서 updateconfig호출
    }

    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)
    {
        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();
    }

    // 기지국이랑 단말 설정 다 하고
    // RAN설정================================================================
    //  create the internet and install the IP stack on the UEs
    // get SGW/PGW and create a single RemoteHost
    Ptr<Node> pgw = nrEpcHelper->GetPgwNode();         // 인터넷으로 나가는 출구 역할(EPC에서 PGW로 보냄)
    NodeContainer remoteHostContainer;                 // 원격 호스트를 담을 컨테이너
    remoteHostContainer.Create(1);                     // 인터넷에 연결된 서버 노트 생성
    Ptr<Node> remoteHost = remoteHostContainer.Get(0); // 생성한 노트 포인터로 꺼냄
    InternetStackHelper internet;
    internet.Install(remoteHostContainer);
    // remoteHost에 TCP/IP 스택 설치 이걸해야 인터넷에서 패킷 주고 받을 수 있음

    // connect a remoteHost to pgw. Setup routing too
    PointToPointHelper p2ph;
    p2ph.SetDeviceAttribute("DataRate", DataRateValue(DataRate("100Gb/s")));
    p2ph.SetDeviceAttribute("Mtu", UintegerValue(2500));
    p2ph.SetChannelAttribute("Delay", TimeValue(Seconds(0.000)));
    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);
    // pgw와 remotehost직접 연결(100Gbps 속도, 0초 지연, 2500 MTU(최대 전송 패킷))

    Ipv4AddressHelper ipv4h;
    Ipv4StaticRoutingHelper ipv4RoutingHelper;
    ipv4h.SetBase("1.0.0.0", "255.0.0.0");
    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);
    // PGW/remoteHost에 IP 주소 부여(prefix는 /8 (255.0.0.0))

    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =
        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());
    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address("7.0.0.0"), Ipv4Mask("255.0.0.0"), 1);
    // remotehost에 정적 라우팅
    // 목적지가 7.0.0.0/8인 패킷은 인터페이스 1 (→ PGW)로 보냄
    // UE들(보통 7.x.x.x IP를 받음)에게 보내는 패킷을 PGW를 통해 전달

    internet.Install(ueNodes);
    Ipv4InterfaceContainer ueIpIface;
    ueIpIface = nrEpcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));
    // 각 ue에 TCP/IP 스택 설치, EPC를 통해 각 UE주소 할당(위에 정의한대로 7.0.0.X형태)
    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);
    // remotehost ip주소 저장 (서버 접속용으로 사용)
    //[UE] ---(5G 무선)--> [gNB] --> [PGW] <--(P2P)-- [remoteHost]

    // Set the default gateway for the UEs
    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)
    {
        Ptr<Ipv4StaticRouting> ueStaticRouting =
            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());
        // UE 노드의 라우팅 테이블에 접근
        ueStaticRouting->SetDefaultRoute(nrEpcHelper->GetUeDefaultGatewayAddress(), 1);
        // 기본 게이트웨이 주소 설정
    }

    // attach UEs to the closest gNB before creating the dedicated flows
    nrHelper->AttachToClosestGnb(ueNetDev, gnbNetDev);
    // ue들을 가장 가까운 gnb에 연결함(RRC, BWP매핑, DRB 생성)

    // install UDP applications
    uint16_t numFlowsUe = 4; // UE마다 세개의 flow 생성
    uint16_t dlPort = 1234;
    uint16_t ulPort = dlPort + gNbNum * ueNumPergNb * numFlowsUe + 1;
    // dl ul 포트 할당

    ApplicationContainer clientApps;
    ApplicationContainer serverApps;

    bool disableDl = false;
    bool disableUl = false;
    uint32_t udpPacketSizeBe = 1252;
    uint32_t lambdaUll = 10000;

    for (uint32_t u = 0; u < ueNodes.GetN(); ++u) // 각 단말마다 할당
    {
        for (uint16_t flow = 0; flow < numFlowsUe; ++flow) // 각 플로우 마다 할당
        {
            if (!disableDl)
            {
                PacketSinkHelper dlPacketSinkHelper(
                    "ns3::UdpSocketFactory",
                    InetSocketAddress(Ipv4Address::GetAny(), dlPort));
                // UE가 수신쪽임 (지정된 포트로 오는 어떤 데이터든(GetAny) 받아줌)
                serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));

                UdpClientHelper dlClient(ueIpIface.GetAddress(u),
                                         dlPort); // 목적지(UE IP), 목적지 포트
                dlClient.SetAttribute("PacketSize",
                                      UintegerValue(udpPacketSizeBe)); // 패킷 하나의 크기
                dlClient.SetAttribute(
                    "Interval",
                    TimeValue(Seconds(1.0 / lambdaUll))); // 전송 주기(패킷 전송률 제어)
                dlClient.SetAttribute("MaxPackets",
                                      UintegerValue(0xFFFFFFFF)); // 엄청나게 많은 패킷 16진수
                clientApps.Add(dlClient.Install(remoteHost));

                Ptr<NrEpcTft> tft =
                    Create<NrEpcTft>(); // Traffic Flow Template(특정 조건을 만족하는 패킷을 어떤
                                        // Bearer에 매핑할지 결정)
                NrEpcTft::PacketFilter dlpf;
                dlpf.localPortStart = dlPort;
                dlpf.localPortEnd = dlPort;
                ++dlPort; // 다음 flow위해 포트번호 증가 => 즉 각 flow마다 다른 포트 사용중
                tft->Add(dlpf);

                // QoS클래스(QCI) 결정
                enum NrEpsBearer::Qci q;
                if (flow == 0)
                {
                    q = NrEpsBearer::NGBR_LOW_LAT_EMBB;
                }
                else if (flow == 1)
                {
                    q = NrEpsBearer::GBR_CONV_VOICE;
                }
                else if (flow == 2)
                {
                    q = NrEpsBearer::NGBR_VIDEO_TCP_PREMIUM;
                }
                else if (flow == 3)
                {
                    q = NrEpsBearer::NGBR_VOICE_VIDEO_GAMING;
                }
                else
                {
                    q = NrEpsBearer::NGBR_VIDEO_TCP_DEFAULT;
                }

                // EPS Bearer 생성 + 활성화
                NrEpsBearer bearer(q);
                nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
            }

            if (!disableUl)
            {
                PacketSinkHelper ulPacketSinkHelper(
                    "ns3::UdpSocketFactory",
                    InetSocketAddress(Ipv4Address::GetAny(), ulPort));
                serverApps.Add(ulPacketSinkHelper.Install(remoteHost));

                UdpClientHelper ulClient(remoteHostAddr, ulPort);
                ulClient.SetAttribute("PacketSize", UintegerValue(udpPacketSizeBe));
                ulClient.SetAttribute("Interval", TimeValue(Seconds(1.0 / lambdaUll)));
                ulClient.SetAttribute("MaxPackets", UintegerValue(0xFFFFFFFF));
                clientApps.Add(ulClient.Install(ueNodes.Get(u)));

                Ptr<NrEpcTft> tft = Create<NrEpcTft>();
                NrEpcTft::PacketFilter ulpf;
                ulpf.remotePortStart = ulPort;
                ulpf.remotePortEnd = ulPort;
                ++ulPort;
                tft->Add(ulpf);

                enum NrEpsBearer::Qci q;
                if (flow == 0)
                {
                    q = NrEpsBearer::NGBR_LOW_LAT_EMBB;
                }
                else if (flow == 1)
                {
                    q = NrEpsBearer::GBR_CONV_VOICE;
                }
                else if (flow == 2)
                {
                    q = NrEpsBearer::NGBR_VIDEO_TCP_PREMIUM;
                }
                else if (flow == 3)
                {
                    q = NrEpsBearer::NGBR_VOICE_VIDEO_GAMING;
                }
                else
                {
                    q = NrEpsBearer::NGBR_VIDEO_TCP_DEFAULT;
                }
                NrEpsBearer bearer(q);
                nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);
            }
        }
    }

    double simTime = 1;           // seconds
    double udpAppStartTime = 0.4; // seconds

    // start UDP server and client apps
    serverApps.Start(Seconds(udpAppStartTime));
    clientApps.Start(Seconds(udpAppStartTime));
    serverApps.Stop(Seconds(simTime));
    clientApps.Stop(Seconds(simTime));

    // enable the traces provided by the nr module
    // nrHelper->EnableTraces();//nr모듈에서 제공하는 내부(PHY,MAX,RLC) 트레이스

    FlowMonitorHelper flowmonHelper;
    NodeContainer endpointNodes;
    endpointNodes.Add(remoteHost);
    endpointNodes.Add(ueNodes);

    Ptr<ns3::FlowMonitor> monitor =
        flowmonHelper.Install(endpointNodes); // 각 노드 간의 UDP flow 추적
    // BinWidth는 히스토그램 형태로 분포 나타낼 때 간격을 몇 초 단위로 나눌지
    monitor->SetAttribute("DelayBinWidth", DoubleValue(0.001)); // 지연 측정 구간(1ms)
    monitor->SetAttribute("JitterBinWidth",
                          DoubleValue(0.001)); // 지터(패킷 간 전송 간격의 변화량) 측정 구간(1ms)
    // 패킷이 규칙적으로 오지 않고 도착할 때 그 불안정성 측정
    monitor->SetAttribute("PacketSizeBinWidth",
                          DoubleValue(20)); // 패킷 크기 히스토그램 구간(20바이트 단위)
                                            // 패킷의 크기를 몇 바이트 단위로 나눌지

    Simulator::Stop(Seconds(simTime)); // 몇초뒤에 시뮬 멈출지 결정
    Simulator::Run();

    /*
     * To check what was installed in the memory, i.e., BWPs of gNB Device, and its configuration.
     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy ->
    NrPhyMacCommong-> Numerology, Bandwidth, ... GtkConfigStore config; config.ConfigureAttributes
    ();
    */

    // Print per-flow statistics
    monitor->CheckForLostPackets();
    // FlowMonitor 내부에서 전송된 패킷 수 vs 수신된 패킷 수 비교해서
    // 손실된 패킷 수를 계산
    Ptr<Ipv4FlowClassifier> classifier =
        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());
    // flow monitor가 각 트래픽 흐름(flow)에 고유한 ID부여
    // 그리고 classifier가 FlowID를 실제 정보(IP, vhxm) 바꿔줌
    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats(); // 통계
    // 보낸/받은 패킷 수, 보낸 바이트 수, 전체 지연 시간 합, 마지막 패킷 수신 지점   정보 갖고있음

    double averageFlowThroughput = 0.0;
    double averageFlowDelay = 0.0;

    std::string simTag = "1gnb1ue_result";
    std::string outputDir = "./";

    std::ofstream outFile;
    std::string filename = outputDir + "/" + simTag;
    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);
    if (!outFile.is_open())
    {
        std::cerr << "Can't open file " << filename << std::endl;
        return 1;
    }
    outFile.setf(std::ios_base::fixed);
    // output file설정 끝

    // flowmonitor결과를 부석해서 udp flow의 성능(throughput, delay, jitter)을 파일로 출력
    // for문 통해 각 flow마다 순회
    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();
         i != stats.end();
         ++i)
    {
        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);
        std::stringstream protoStream;
        protoStream << (uint16_t)t.protocol;
        if (t.protocol == 6)
        {
            protoStream.str("TCP");
        }
        if (t.protocol == 17)
        {
            protoStream.str("UDP");
        }
        outFile << "Flow " << i->first << " (" << t.sourceAddress << ":" << t.sourcePort << " -> "
                << t.destinationAddress << ":" << t.destinationPort << ") proto "
                << protoStream.str() << "\n";
        outFile << "  Tx Packets: " << i->second.txPackets << "\n";
        outFile << "  Tx Bytes:   " << i->second.txBytes << "\n";
        outFile << "  TxOffered:  "
                << i->second.txBytes * 8.0 / (simTime - udpAppStartTime) / 1000 / 1000 << " Mbps\n";
        outFile << "  Rx Bytes:   " << i->second.rxBytes << "\n";
        if (i->second.rxPackets > 0)
        {
            // Measure the duration of the flow from receiver's perspective
            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -
            // i->second.timeFirstTxPacket.GetSeconds ();
            double rxDuration = (simTime - udpAppStartTime);

            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;
            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;

            outFile << "  Throughput: " << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000
                    << " Mbps\n";
            outFile << "  Mean delay:  "
                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << " ms\n";
            // outFile << "  Mean upt:  " << i->second.uptSum / i->second.rxPackets / 1000/1000 << "
            // Mbps \n";
            outFile << "  Mean jitter:  "
                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << " ms\n";
        }
        else
        {
            outFile << "  Throughput:  0 Mbps\n";
            outFile << "  Mean delay:  0 ms\n";
            outFile << "  Mean jitter: 0 ms\n";
        }
        outFile << "  Rx Packets: " << i->second.rxPackets << "\n";
    }

    outFile << "\n\n  Mean flow throughput: " << averageFlowThroughput / stats.size() << "\n";
    outFile << "  Mean flow delay: " << averageFlowDelay / stats.size() << "\n";

    outFile.close();

    std::ifstream f(filename.c_str());

    if (f.is_open())
    {
        std::cout << f.rdbuf();
    }

    Simulator::Destroy();
    return 0;
}
